sock = socket(AF_INET, SOCK_STREAM, 0);//AF_INET为指定socket的协议是tcp/ip协议，SOCK_STREAM只接受tcp的数据，具体参数也可以通过 man socket 来查看，linux下对单个进程的文件句柄数是有限制的，用ulimit -n命令可以查看。所以socket的初始化，在一个进程里面不能启动超过ulimit -n个，否则会报错。

if(sock == -1){
        
       std::cout << "创建socket失败~" << std::endl;

	exit(0);
        
}



sockaddr_in tmp;
    
tmp.sin_family = AF_INET;
    
tmp.sin_port = htons(port);//这儿有个网络字节序的概念。不同的操作系统、平台，针对数据存储的字节序是有不同的，大致分为，小端法和大端法，比如 整型 2 二进制的顺序为00000000 00000000 00000000 00000010 在大端法上的字节序为0x187 0x186 0x185 0x184： 在小端法上的表示为：0x184 0x185 0x186 0x187,如果搞混的话 后果很严重。我们平常的电脑都是小端字节序，而网络字节序全部为大端序列。
    
tmp.sin_addr.s_addr = htonl(0);//内网 外网都可以访问
    
int BindRes = bind(sock, (sockaddr *)&tmp, sizeof(tmp));//这儿bind内部使用的是，sockaddr这个结构体，但是它存在一定的弊端，所以我们这儿改用sockaddr_in，需要先引用

int listenRes = listen(sock, 10);//开始接受用户的连接,10是指最大连接数，具体含义为，如果有10个连接有数据传输，但是都没有用accept来接收数据，那么第11个进来，前面的第一个连接的数据就会被丢掉。如果被accept了，那么这里面的数字就会减一 那么就是9了。


if(sock <= 0)return false;
    
int flags = fcntl(sock, F_GETFL, 0);//查看当前sock的阻塞状态.什么是阻塞？比如说read()如果此时buff()里面有5bytes的数据，而我们要read（）10bytes的数据对于block：那么只有等到buff里面有10bytes的数据read（）才返回，不管多长时间都要等待对于nonblock：马上返回5bytes的字节。如果buff()中无数据，非阻塞，read（）在没有接收到数据时会立即返回0，阻塞read()在没有接收到数据时会阻塞一段时间，时间过后还没有收到会返回一个值
    
if(flags < 0)return false;
    
if(isblock){//如果设置为阻塞，即传值为true
        
    flags = flags&~O_NONBLOCK;

}else{//如果设置为非阻塞，即传值为false
    
    flags = flags|O_NONBLOCK;
        
}
    
fcntlRes = fcntl(sock, F_SETFL, flags);//设置阻塞还是非阻塞


while(true){

	sockaddr_in clientaddr;

	socklen_t len = sizeof(clientaddr);

	int client = accept(sock, (sockaddr *)&clientaddr, &len);//如果accept成功，那么会返回一个新的socket，这个socket就是用来跟连上来的客户端进行通信的。因为上面设置了阻塞模式，会阻塞等待。

	std::string clientip = inet_ntoa(clientaddr.sin_addr);//拿到客户端的IP信息

	unsigned short clientport = ntohs(clientaddr.sin_port);//拿到客户端的端口信息，需要将网络字节序改为本地字节序

	/*对连接上的socket进行数据处理，应该放到tcpThread这个类中的run方法中去

		while(true){

        		char str[1024];
    
        		long l = recv(client, str, sizeof(str)-1, 0);
        
        		if(l == -1){
            
            			std::cout << "该线程读取数据失败，或该线程的连接端已经丢失" << std::endl;
            
            			break;
            
        		}
            
        		str[l] = '\0';
    
        		std::cout << str << std::endl;
        
        		char *sendata = "recv success";

        		long size = 0;

        		while(true){

                    if(size > leng)break;

                    long len = send(client, sendata+size, leng-size, 0);//发送数据，返回数据大小 字节

                    size = size + len;

                }
        
        		if(sendlen == -1){
        
            			std::cout << "发送数据失败，线程退出" << std::endl;
            
            			break;
            
        		}
    		}

	*/	

	/*开启子线程去处理连接上来的socket请求

	tcpThread *tcpthread = new tcpThread;//子线程中需要用的方法，一般把连接上的socket的数据的数据放到这儿处理

	tcpthread->sock = client;
	
	std::thread sth(&tcpThread::run, tcpthread);/生成子线程，thread的标准用法，std::thread t1(&HelloWorld::myThread,this);//创建一个分支线程，回调到TcpThread函数里中的run函数

	sth.detach();//detach调用之后，目标线程就成为了守护线程，驻留后台运行，与之关联的std::thread对象失去对目标线程的关联，无法再通过std::thread对象取得该线程的控制权。当线程主函数执行完之后，线程就结束了，运行时库负责清理与该线程相关的资源。

	*/
}






