1、在任意文件夹下创建文件，以.def结尾，内容如下：

    eg:

        string myFunctionName();

2、运行命令：//ext_skel这个脚本在你编译php之前已经有了，就在ext文件夹中。skeletok这个文件夹也在编译前已经有了，也在ext文件夹中。

        ext_skel --extname=myFunctionName --skel=skeletok的路径 --proto=上面创建的.def文件的路径   //这儿会创建一个myFunctionName的文件夹，这就是我们要创建的整个php扩展的骨架，接下来所有的操作都在这个文件夹下。

3、编译上面生成的文件夹下的config.m4文件。这个config.m4文件，是我们在该文件夹下运行phpize命令需要结合的文件，运行之后才会生成configure脚本。文件内容如下：

        PHP_ARG_ENABLE(mike, Whether to enable Mike extension, [ --enable-mike Enable Mike Extension])  //三个参数，第一个参数是我们的扩展名mike(注意不用加引号)，第二个参数是当我们运行./configure脚本时显示的内容，最后一个参数则是我们在调用./configure –help时显示的帮助信息

        if test "$PHP_MYFUNCTIONNAME" != "no"; then

            PHP_SUBST(MYFUNCTIONNAME_SHARED_LIBADD)     //扩展构建为共享模块时需要

            PHP_NEW_EXTENSION(myFunctionName, php_myFunctionName.c, $ext_shared)    //声明了这个扩展的名称、需要的源文件名、此扩展的编译形式。如果我们的扩展使用了多个文件，便可以将这多个文件名罗列在函数的参数里。最后的$ext_shared参数用来声明这个扩展不是一个静态模块，而是在php运行时动态加载的
        fi


4、接下来，我们就需要去编辑myFunctionName.c文件，找到PHP_FUNCTION(myFunctionName){.....}  //所有的内容都写在这儿。

    内容举例：


        char *str = NULL;

        int totalnum = ZEND_NUM_ARGS();

        int strlen;

        int n;

        if(zend_parse_parameters(totalnum TSRMLS_CC, "ss", &str, &strlen, &n) == FUILURE){//接收参数失败      //第二个参数：
                                                                                                                  l	long	符号整数
                                                                                                                  d	double	浮点数
                                                                                                                  s	char *, int	二进制字符串，长度
                                                                                                                  b	zend_bool	逻辑型（1或0）
                                                                                                                  r	zval *	资源（文件指针，数据库连接等）
                                                                                                                  a	zval *	联合数组
                                                                                                                  o	zval *	任何类型的对象
                                                                                                                  O	zval *	指定类型的对象。需要提供目标对象的类类型
                                                                                                                  z	zval *	无任何操作的zval

            php_error(......);

        }


        设置返回值并且结束函数         设置返回值                   宏返回类型和参数

        RETURN_LONG(l)	            RETVAL_LONG(l)	            整数
        RETURN_BOOL(b)	            RETVAL_BOOL(b)	            布尔数(1或0)
        RETURN_NULL()	            RETVAL_NULL()	            NULL
        RETURN_DOUBLE(d)	        RETVAL_DOUBLE(d)	        浮点数
        RETURN_STRING(s, dup)	    RETVAL_STRING(s, dup)	    字符串。如果dup为1，引擎会调用estrdup()重复s，使用拷贝。如果dup为0，就使用s
        RETURN_STRINGL(s, l, dup)	RETVAL_STRINGL(s, l, dup)	长度为l的字符串值。与上一个宏一样，但因为s的长度被指定，所以速度更快。
        RETURN_TRUE	                RETVAL_TRUE	                返回布尔值true。注意到这个宏没有括号。
        RETURN_FALSE	            RETVAL_FALSE	            返回布尔值false。注意到这个宏没有括号。
        RETURN_RESOURCE(r)	        RETVAL_RESOURCE(r)	        资源句柄。






