一、文件锁：
           1、独占式写锁(已经上锁，别的进程不能读写，要让其他进程不阻塞可用 LOCK_EX | LOCK_NB,注意进程2边都要用这个)
                $fp = fopen("/root/test.txt", "w");

                if(flock($fp, LOCK_EX)){

                    echo "上锁成功";

                    fwrite($fp, "tangwei");

                    sleep(100);

                    flock($fp, LOCK_UN);

                }else{

                    echo "上锁失败";

                }

                fclose($fp);


           2、共享式读锁（自己和别的进程都能读取数据但是不能写,一般读取的时候不写数据，所以不用LOCK_NB ）

                $fp = fopen("/root/test.txt", "r");

                if(flock($fp, LOCK_SH)){

                    echo "上锁成功";

                    echo fread($fp, filesize("/root/test.txt"));

                    sleep(100);

                    flock($fp, LOCK_UN);

                }else{

                    echo "上锁失败";

                }

                fclose($fp);

二、sysvsem中的信号量：
           sem_get 创建信号量

           sem_remove 删除信号量（一般不用）

           sem_acquire 请求得到信号量

           sem_release 释放信号量。和 sem_acquire 成对使用

            使用：
                $key = ftok('/tmp', 'c');

                $sem = sem_get($key);


三、sync的互斥锁：

        $mutex = new SyncMutex("tangwei");

        $mutex->lock(3000);//等待互斥锁 -1为无限锁 3000为锁定3000秒,如果一个进程占用着的话，除非自己unlock或者本进程结束，否则别的进程是获取不到的

        $mutex->unlock();//解锁互斥锁

        例子：仅测试syncMutex的使用

            $mutex = new SyncMutex("UniqueName");

            for($i=0; $i<2; $i++){

                $pid = pcntl_fork();

                if($pid <0){

                    die("fork failed\r\n");

                }elseif ($pid>0){

                    echo "parent process \r\n";

                }else{

                    echo "child process {$i} is born. \r\n";

                    $res = $mutex->lock(-1);

                    if($res){
                        echo "process $i get mutex\r\n";

                        sleep(60);

                        $mutex->unlock();

                        echo "process $i is exit\r\n";


                    }else{
                        echo "get mutex fail\r\n";
                    }

                    sleep(600);

                }
            }


四、sync的信号量：
        $mutex = new SyncSemaphore("tangwei", 2);//用法类似syncMutex的使用，不同的是，可以指定被几个进程同时占有

        $mutex->lock(3000);//等待互斥锁 -1为无限锁 3000为锁定3000秒

        $mutex->unlock();//解锁互斥锁

        例子不写了！！！



五、sync的event模块：

        // In a web application:
        $event = new SyncEvent("GetAppReport");
        $event->fire();//解锁一个等待，先设定等待的就会被先解锁，后等待的就会被后解锁

        // In a cron job:
        $event = new SyncEvent("GetAppReport");
        $event->wait();//设定一个等待


        例子：

                for($i=0; $i<2; $i++){

                    $pid = pcntl_fork();

                    if($pid <0){

                        die("fork failed\r\n");

                    }elseif ($pid>0){

                        echo "parent process \r\n";

                    }else{

                        switch($i){

                            case 0:
                                    echo "process $i is born\r\n";

                                    $event = new SyncEvent("tangwei");

                                    $event->wait();

                                    echo "process $i is crocess over\r\n";

                                    exit;

                                    break;
                            case 1:
                                    echo "process $i is born\r\n";

                                    $event = new SyncEvent("tangwei");

                                    $event->wait();

                                    echo "process $i is crocess over\r\n";

                                    exit;

                                    break;

                        }

                    }
                }

六、sync的SyncReaderWriter()类：
                $readwrite = new SyncReaderWriter("FileCacheLock");
                $readwrite->readlock();//共享式读锁，可以同时让多个进程占用
                /* ... */
                $readwrite->readunlock();

                $readwrite->writelock();//独占式写锁，自己占用，别人不能占用
                /* ... */
                $readwrite->writeunlock();

        例子：
                $readWrite = new SyncReaderWriter("UniqueName");

                for($i=0; $i<2; $i++){

                    $pid = pcntl_fork();

                    if($pid <0){

                        die("fork failed\r\n");

                    }elseif ($pid>0){

                        echo "parent process \r\n";

                    }else{

                        echo "child process {$i} is born. \r\n";

                        $res = $readWrite->writelock(-1);

                        if($res){
                            echo "process $i get mutex\r\n";

                            sleep(10);

                            $readWrite->writeunlock();

                            echo "process $i is exit\r\n";


                        }else{
                            echo "get mutex fail\r\n";
                        }

                        sleep(600);

                    }
                }



























